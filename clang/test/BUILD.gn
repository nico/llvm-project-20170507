import("//clang/lib/ARCMigrate/enable.gni")
import("//clang/lib/StaticAnalyzer/Frontend/enable.gni")
import("//llvm/include/llvm/Config/config.gni")

template("write_lit_config") {
  action(target_name) {
    script = "//gn/write_version_inc.py"  # FIXME: rename
    input = invoker.input
    output = invoker.output

    sources = [
      input,
    ]
    args = [
      rebase_path(input, root_out_dir),
      "-o",
      rebase_path(output, root_out_dir),
      "--from_to",

      # FIXME: Do all these paths have to be absolute?
      # FIXME: Get all paths from a central gni file (or one per project)

      "@LIT_SITE_CFG_IN_HEADER@=## Autogenerated from $input, do not edit",

      # FIXME: Why is this a toggle? It always gets the same value everywhere.
      "@LIT_SITE_CFG_IN_FOOTER@=import lit.llvm; lit.llvm.initialize(lit_config, config)",
      "@CLANG_ANALYZER_WITH_Z3@=0",
      "@CLANG_BINARY_DIR@=" +
          rebase_path(get_label_info("//clang", "target_out_dir")),
      "@CLANG_BUILD_EXAMPLES@=0",
      "@CLANG_DEFAULT_CXX_STDLIB@=",
      "@CLANG_SOURCE_DIR@=" + rebase_path("//clang"),
      "@CLANG_TOOLS_DIR@=" + rebase_path("$root_out_dir/bin"),
      "@CMAKE_CXX_COMPILER@=c++",  # FIXME: better
      "@ENABLE_SHARED@=0",
      "@ENABLE_BACKTRACES@=1",
      "@HOST_ARCH@=x86_64",  # FIXME: better
      "@LLVM_BUILD_MODE@=.",
      "@LLVM_BINARY_DIR@=" +
          rebase_path(get_label_info("//llvm", "target_out_dir")),
      "@LLVM_HOST_TRIPLE@=$llvm_host_triple",
      "@LLVM_LIBS_DIR@=",  # needed only for shared builds
      "@LLVM_LIT_TOOLS_DIR@=",  # Intentionally empty, matches cmake build.
      "@LLVM_PLUGIN_EXT@=",  # FIXME
      "@LLVM_SOURCE_DIR@=" + rebase_path("//llvm"),  # FIXME: assumes monorepo
      "@LLVM_TOOLS_DIR@=" + rebase_path("$root_out_dir/bin"),
      "@LLVM_USE_SANITIZER@=",
      "@PYTHON_EXECUTABLE@=$python_path",
      "@SHLIBDIR@=",  # FIXME!
      "@TARGET_TRIPLE@=$llvm_target_triple",
    ]
    if (clang_enable_arcmt) {
      args += [ "@CLANG_ENABLE_ARCMT@=1" ]
    } else {
      args += [ "@CLANG_ENABLE_ARCMT@=0" ]
    }
    if (clang_enable_static_analyzer) {
      args += [ "@CLANG_ENABLE_STATIC_ANALYZER@=1" ]
    } else {
      args += [ "@CLANG_ENABLE_STATIC_ANALYZER@=0" ]
    }

    if (llvm_enable_zlib) {
      args += [ "@HAVE_LIBZ@=1" ]
    } else {
      args += [ "@HAVE_LIBZ@=0" ]  # Must be 0.
    }

    outputs = [
      output,
    ]
  }
}

lit_site_cfg_file = "$root_gen_dir/clang/test/lit.site.cfg.py"
write_lit_config("lit_site_cfg") {
  input = "//clang/test/lit.site.cfg.py.in"
  output = lit_site_cfg_file
}

lit_unit_site_cfg_file = "$root_gen_dir/clang/test/Unit/lit.site.cfg.py"
write_lit_config("lit_unit_site_cfg") {
  input = "//clang/test/Unit/lit.site.cfg.py.in"
  output = lit_unit_site_cfg_file
}

action("check-clang") {
  script = "$root_out_dir/llvm-lit"
  if (host_os == "win") {
    script += ".py"
  }
  args = [
    "-sv",
    "--param",
    "clang_site_config=" + rebase_path(lit_site_cfg_file, root_out_dir),
    "--param",
    "clang_unit_site_config=" +
        rebase_path(lit_unit_site_cfg_file, root_out_dir),
    rebase_path(".", root_out_dir),
  ]
  outputs = [
    "$target_gen_dir/run-lit",  # Non-existing, so that ninja runs it each time.
  ]

  # Since check-clang is always dirty, //:default doesn't depend on it so that
  # it's not part of the default ninja target.  Hence, check-clang shouldn't
  # have any deps except :test. so that the default target is sure to build
  # all the deps.
  deps = [
    ":test",
  ]
  testonly = true

  pool = "//:console"
}

# This target should contain all dependencies of check-clang.
# //:default depends on it, so that ninja's default target builds all
# prerequisites for check-clang but doesn't run check-clang itself.
group("test") {
  deps = [
    ":lit_site_cfg",
    ":lit_unit_site_cfg",
    "//clang/lib/Headers",
    "//clang/tools/c-index-test",
    "//clang/tools/clang-diff",
    "//clang/tools/clang-format",
    "//clang/tools/clang-import-test",
    "//clang/tools/clang-offload-bundler",
    "//clang/tools/clang-refactor",
    "//clang/tools/clang-rename",
    "//clang/tools/diagtool",
    "//clang/tools/driver:symlinks",
    "//clang/unittests",
    "//clang/utils/TableGen:clang-tblgen",
    "//clang/utils/hmaptool",
    "//llvm/tools/llc",
    "//llvm/tools/llvm-bcanalyzer",
    "//llvm/tools/llvm-cat",
    "//llvm/tools/llvm-config",
    "//llvm/tools/llvm-dis",
    "//llvm/tools/llvm-lto",
    "//llvm/tools/llvm-lto2",
    "//llvm/tools/llvm-modextract",
    "//llvm/tools/llvm-nm",
    "//llvm/tools/llvm-objdump",
    "//llvm/tools/llvm-profdata",
    "//llvm/tools/llvm-readobj:symlinks",
    "//llvm/tools/llvm-symbolizer",
    "//llvm/tools/opt",
    "//llvm/utils/FileCheck",
    "//llvm/utils/count",
    "//llvm/utils/llvm-lit",
    "//llvm/utils/not",
  ]
  if (clang_enable_arcmt) {
    deps += [
      "//clang/tools/arcmt-test",
      "//clang/tools/c-arcmt-test",
    ]
  }
  if (clang_enable_static_analyzer) {
    deps += [
      "//clang/tools/clang-check",
      "//clang/tools/clang-func-mapping",
    ]
  }

  # FIXME: clang_build_examples
  testonly = true
}
